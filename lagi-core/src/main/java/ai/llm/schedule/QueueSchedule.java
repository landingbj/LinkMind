package ai.llm.schedule;

import ai.llm.adapter.ILlmAdapter;
import ai.manager.LlmManager;
import ai.mr.pipeline.Consumer;
import ai.mr.pipeline.Producer;
import ai.mr.pipeline.ProducerConsumerPipeline;
import ai.openai.pojo.ChatCompletionRequest;
import ai.openai.pojo.ChatCompletionResult;
import io.milvus.param.R;

import java.util.List;
import java.util.Map;
import java.util.Queue;
import java.util.UUID;
import java.util.concurrent.BlockingQueue;
import java.util.stream.Collectors;

public class QueueSchedule {


//    private Cache completionResultCache;

//    private Map<String, Consumer<ChatCompletionResult>> consumers;

//    private ProducerConsumerPipeline pipeline;
    private Map<String, BlockingQueue<ChatCompletionRequest>> blockingQueueMap;

    public QueueSchedule() {
        // TODO 2024/11/15 Q1 Create a cache user to store the results generated by the model for external retrieval
        // TODO 2024/11/15 Q2 Generate the corresponding number of consumers based on llmAdapters
        List<ILlmAdapter> adapters = LlmManager.getInstance().getAdapters();
//        consumers = adapters.stream().collect(Collectors.toMap(ILlmAdapter::getModelName,
//        adapter -> {
//        BlockingQueue<ChatCompletionRequest> consumerQueue = new BlockingQueue<>();
//            blockingQueueMap.put(blockingQueueMap);
//        return new LlmConsumer(adapter, consumerQueue) })
        // TODO 2024/11/15 Q3 Create an inherited from ProducerConsumerPipeline ScheduleLlmAdapterPipeline connection producer and consumer
//        ProducerConsumerPipeline pipeline = new ScheduleLlmAdapterPipeline(adapters);
//        pipeline.connect(producer);
//        pipeline.connect(Consumers);
//        pipeline.start();
        // new producerPipeline(queue, consumers);
    }

    public static String generateId() {
        return UUID.randomUUID().toString().replace("-", "");
    }

    public ChatCompletionResult schedule(String id, ChatCompletionRequest chatCompletionRequest) {
        // TODO 2024/11/15 Q4  Pass in an object data that contains an id, a countdownLatch object, and a chatCompletionRequest object
        // TODO 2024/11/15 Q5 pipeline.producerProcess(data); Producer pipeline execution, perform flow control, and push data to the corresponding consumer queue.
        // TODO 2024/11/15 Q6  When the corresponding consumer finishes processing the data, the countdownLatch is 0.
//        pipeline.produce(data)
        // TODO 2024/11/15 Q7 Wait for countdownLatch to return and get the result from the cache
        return null;
    }

}
